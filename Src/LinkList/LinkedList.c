/*****************************************************************************************************
 * @file		LinkedList.c
 * @author		Reglucis
 * @version		V0.1
 * @date		2024/06/06
 * @brief		提供链表操作支持
 * @email		Reglucis@outlook.com
 ****************************************************************************************************
 * @details
 *
 *
 * History Ver:
 *				V0.1		2024/06/06		Reglucis		创建文件
 *
 * @todo
 *
 *
 ****************************************************************************************************
 * @test
 *				Homehomehome亲自测试很好用
 *
 * @bug
 *
 *
 ****************************************************************************************************
 * @example
 *
 *
 ***************************************************************************************************/
/*------------------------------------------------------------ 头文件引用 ------------------------------------------------------------*/

/*------------------------------------------------------------ 数据结构 ------------------------------------------------------------*/

/*------------------------------------------------------------ 全局变量区 ------------------------------------------------------------*/

/*------------------------------------------------------------ 宏嵌套区 ------------------------------------------------------------*/

/*------------------------------------------------------------ 函数实现区 ------------------------------------------------------------*/
/*————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*/
#pragma region 双向链表

#include "LinkedList.h"

/********************************************************************
 * @brief		创建一个新的结点
 * @param		item_size: 结点保存数据结构的大小
 * @return		结点实例
 * @example		temp = LList_New(sizeof(type))
 ********************************************************************/
void* LList_New(uint32_t item_size)
{
	/*分配空间*/
	void* this = malloc(item_size);
	if (this == NULL)
		return NULL;

	/*将空间清零*/
	memset(this, 0, item_size);
	LList_PointToSelf((LListNode_t*)this);

	return this;
}

/********************************************************************
 * @brief		在目标结点后插入节点
 * @param		prevNode: 目标结点
 * @param		this: 被插入结点
 ********************************************************************/
void LList_Insert(LListNode_t* prevNode, LListNode_t* this)
{
	this->prev			 = prevNode;
	this->next			 = prevNode->next;
	prevNode->next->prev = this;
	prevNode->next		 = this;
}

/********************************************************************
 * @brief		从链表中移出(不释放空间)一个结点
 * @return		被移出结点前一个结点
 * @param		this: 被移出结点
 ********************************************************************/
LListNode_t* LList_Remove(LListNode_t* this)
{
	LListNode_t* prev = this->prev;
	this->prev->next  = this->next;
	this->next->prev  = this->prev;
	LList_PointToSelf(this);
	return prev;
}

/********************************************************************
 * @brief		从链表中删除一个结点(移除并释放空间)
 * @return		被删除结点前一个结点
 * @param		this: 被移出结点
 * @warning		在 foreach 循环中使用此函数，必须保持 this = LList_Delete(this); 的形式
 ********************************************************************/
void* LList_Delete(LListNode_t* this)
{
	LListNode_t* prev = this->prev;
	this->prev->next  = this->next;
	this->next->prev  = this->prev;
	free(this);
	return prev;
}

#pragma endregion
/*————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————*/
